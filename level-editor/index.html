<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Level editor</title>

    <script src="../javascript/libs/jcurry.min.js"></script>

    <style>
        * {
            image-rendering: pixelated;
            overflow: hidden;
        }

        body,
        html {
            background-color: black;
            margin: 0;
            color: white;
        }

        textarea {
            margin-top: 20px;
            overflow: scroll;
            resize: none;
        }


        .hamburger {
            position: absolute;
            top: 50px;
            right: 0;
            padding: 10px;
            border: 3px solid white;
            border-right: 0;
            z-index: 100;
        }

        #menu {
            position: absolute;
            top: 0;
            right: 0;
            border: 3px solid white;
            border-right: 0;
            height: 99vh;
            background-color: black;
            width: 324px;
        }

        .open-menu {
            animation: open-menu 0.2s linear;
        }

        .close-menu {
            animation: close-menu 0.2s linear;
        }

        @keyframes open-menu {
            0% {
                right: -324px
            }

            100% {
                right: 0;
            }
        }

        @keyframes close-menu {
            0% {
                right: 0px
            }

            100% {
                right: -324px;
            }
        }



        .bar1,
        .bar2,
        .bar3 {
            width: 35px;
            height: 5px;
            background-color: white;
            margin: 6px 0;
            transition: 0.4s;
        }

        .change .bar1 {
            -webkit-transform: rotate(-45deg) translate(-9px, 6px);
            transform: rotate(-45deg) translate(-9px, 6px);
        }

        .change .bar2 {
            opacity: 0;
        }

        .change .bar3 {
            -webkit-transform: rotate(45deg) translate(-8px, -8px);
            transform: rotate(45deg) translate(-8px, -8px);
        }


        .container-radio {
            display: block;
            position: relative;
            padding-left: 35px;
            margin-bottom: 12px;
            cursor: pointer;
            font-size: 22px;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            padding-top: 2px;
        }

        /* Hide the browser's default radio button */
        .container-radio input {
            position: absolute;
            opacity: 0;
            cursor: pointer;
        }

        /* Create a custom radio button */
        .checkmark {
            position: absolute;
            top: 0;
            left: 0;
            height: 25px;
            width: 25px;
            border: 1px dashed white;
            border-radius: 50%;
        }


        /* When the radio button is checked, add a blue background */
        .container-radio input:checked~.checkmark {
            background-color: white;
        }

        /* Create the indicator (the dot/circle - hidden when not checked) */
        .checkmark:after {
            content: "";
            position: absolute;
            display: none;
        }

        /* Show the indicator (dot/circle) when checked */
        .container-radio input:checked~.checkmark:after {
            display: block;
        }

        input {
            border: 0;
        }

        .undercatergory {
            margin-left: 20px;
        }








        /* The container */
        .container-checks {
            display: block;
            position: relative;
            padding-left: 26px;
            cursor: pointer;
            font-size: 18px;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            padding-top: 2px;
        }

        /* Hide the browser's default checkbox */
        .container-checks input {
            position: absolute;
            opacity: 0;
            cursor: pointer;
            height: 0;
            width: 0;
        }

        /* Create a custom checkbox */
        .checkmark-check {
            position: absolute;
            top: 0;
            left: 0;
            height: 18px;
            width: 18px;
            border: 2px dashed white;
        }


        /* When the checkbox is checked, add a blue background */
        .container-checks input:checked~.checkmark-check {
            background-color: #fff;
        }

        /* Create the checkmark/indicator (hidden when not checked) */
        .checkmark-check:after {
            content: "";
            position: absolute;
            display: none;
        }

        /* Show the checkmark when checked */
        .container-checks input:checked~.checkmark-check:after {
            display: block;
        }
    </style>

</head>

<body>
    <canvas id="canvas"></canvas>


    <div class="hamburger">


        <div class="container" onclick="myFunction(this)">
            <div class="bar1"></div>
            <div class="bar2"></div>
            <div class="bar3"></div>
        </div>


    </div>


    <div id="menu" style="display: none;">

        <label class="container-radio">Vertical wall
            <input type="radio" checked="checked" name="radio" value="vwall">
            <span class="checkmark"></span>
        </label>
        <label class="container-radio">Horizontal wall
            <input type="radio" name="radio" value="hwall">
            <span class="checkmark"></span>
        </label>
        <label class="container-radio">Tree
            <input type="radio" name="radio" value="tree">
            <span class="checkmark"></span>
        </label>
        <label class="container-radio">Player spawn
            <input type="radio" name="radio" value="pspawn">
            <span class="checkmark"></span>
        </label>
        <label class="container-radio">Olof spawn
            <input type="radio" name="radio" value="ospawn">
            <span class="checkmark"></span>
        </label>

        <br> <br>

        <div class="olof-changer">
            <span style="font-size: 20px;">Olof:</span> <br>

            <label class="undercatergory" for="olofSpeed">Speed:
                <input type="text" id="olofSpeed" style="width: 30px;"> <span>(number, default = 5)</span>
            </label>

            <br>

            <label class="container-checks undercatergory">Roaming (moving around)
                <input type="checkbox" checked="checked">
                <span class="checkmark-check"></span>
            </label>


            <label class="undercatergory" for="olofSpeed">Roam radius:
                <input type="text" id="olofSpeed" style="width: 30px;"> <span>(number, pixles)</span>
            </label>


            <br>

            <label class="undercatergory" for="olofSpeed">Hunt radius:
                <input type="text" id="olofSpeed" style="width: 30px;"> <span>(number, pixles)</span>
            </label>

        </div>

        <br>
        <br>
        <br>
        <br>


        <button onclick="document.getElementById('output').value = JSON.stringify(exportGrid(), null, 2)">Export to
            JSON</button>

        <br>

        <textarea id="output" cols="30" rows="10"></textarea>

    </div>









    <script>
        function myFunction(x) {
            x.classList.toggle("change");
            const y = document.getElementById('menu');

            if (y.style.display === "none") {
                y.style.display = 'block';
                y.classList.remove('close-menu');
                y.classList.add('open-menu');
            } else {
                y.classList.remove('open-menu');
                y.classList.add('close-menu');
                setTimeout(() => {
                    y.style.display = "none";
                }, 200);
            }
        }
        const OBJECTS = [
            {
                id: 'vwall',
                img: 'wall_up_down',
                width: 48,
                height: 48,
                dx: 0,
                dy: 0
            },
            {
                id: 'hwall',
                img: 'wall_left_right',
                width: 48,
                height: 48,
                dx: 0,
                dy: 0
            },
            {
                id: 'tree',
                img: 'tree',
                width: 144,
                height: 168,
                dx: 0,
                dy: -72
            },
            {
                id: 'pspawn',
                img: 'char1',
                width: 48,
                height: 48,
                dx: 0,
                dy: 0
            },
            {
                id: 'ospawn',
                img: 'snowman',
                width: 48,
                height: 48,
                dx: 0,
                dy: 0
            }
        ]
        const IMAGES = [];
        for (obj of OBJECTS) {
            const img = new Image(obj.width, obj.height);
            img.src = obj.img + '.png';
            IMAGES.push({
                img: img,
                id: obj.id
            });
        }

        var grid = [];
        var selectedObj = OBJECTS[0];

        var mouseGridX;
        var mouseGridY;

        const WIDTH = 27;
        const HEIGHT = 15;
        const TILESIZE = 48;

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = WIDTH * TILESIZE;
        canvas.height = HEIGHT * TILESIZE;
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        document.onmousemove = function (event) {
            let x = event.pageX;
            let y = event.pageY;

            if (isWithinGrid(x, y)) {
                redraw();

                let gridX = Math.round(x / TILESIZE) - 1;
                let gridY = Math.round(y / TILESIZE) - 1;

                mouseGridX = gridX;
                mouseGridY = gridY;

                ctx.globalAlpha = 0.5;
                drawObj(selectedObj.id, selectedObj.dx, selectedObj.dy, gridX, gridY, selectedObj.width, selectedObj.height);
            }
        }

        document.onclick = function (event) {
            let x = event.pageX;
            let y = event.pageY;

            if (isWithinGrid(x, y) && event.target.id == 'canvas') {
                let gridX = Math.round(x / TILESIZE) - 1;
                let gridY = Math.round(y / TILESIZE) - 1;
                const newobj = JSON.parse(JSON.stringify(selectedObj));
                newobj.x = gridX;
                newobj.y = gridY;

                if (newobj.id === 'pspawn' && grid.find(o => o.id === 'pspawn')) grid.splice(grid.indexOf(grid.find(o => o.id === 'pspawn')), 1);
                if (grid.find(o => o.x === newobj.x && o.y === newobj.y) == undefined) {
                    grid.push(newobj);
                }

                redraw();
            }
        }

        // document.getElementById('objects').onchange = function () {
        //     let newname = document.getElementById('objects').value;

        //     selectedObj = OBJECTS.find(o => o.id == newname);
        // }

        $('input[type=radio][name=radio]').on('change', function () {
            selectedObj = OBJECTS.find(o => o.id == this.value);
        })

        window.oncontextmenu = function (event) {
            for (const o of grid) {
                if (mouseGridX === o.x && mouseGridY == o.y) {
                    grid.splice(grid.indexOf(o), 1);
                    redraw();
                    break;
                }
            }
            event.preventDefault()
        }

        function isWithinGrid(x, y) {
            return x <= WIDTH * TILESIZE && y <= HEIGHT * TILESIZE;
        }

        function getImage(id) {
            return IMAGES.find(i => i.id == id).img;
        }

        function redraw() {
            ctx.globalAlpha = 1;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (const obj of grid) {
                drawObj(obj.id, obj.dx, obj.dy, obj.x, obj.y, obj.width, obj.height);
            }
        }

        function drawObj(id, dx, dy, x, y, width, height) {
            ctx.drawImage(getImage(id), x * TILESIZE + dx, y * TILESIZE + dy, width, height);
        }

        function exportGrid() {
            if (grid.find(x => x.id == 'pspawn') == undefined) {
                alert('Please add a player spawnpoint!');
                return;
            }
            if (grid.find(x => x.id == 'tree') == undefined) {
                alert('This level doesn\'t contain any trees. You\'ll lose immediately.');
            }

            const wallConnections = [];
            const walls = [];
            const trees = [];
            const olofSpawns = [];

            for (const obj of grid) {
                if (obj.id === 'hwall' && wallConnections.find(w => w.includes(obj)) == undefined) {
                    const sameY = grid.filter(w => w.y == obj.y && w.id == obj.id);
                    let connection = [];
                    for (let i = 0; i < WIDTH; i++) {
                        const wall = sameY.find(w => w.x === i);
                        if (wall == undefined) {
                            if (connection.length > 0) wallConnections.push(connection);
                            connection = [];
                        }
                        else {
                            connection.push(wall);
                        }
                    }
                }
                else if (obj.id === 'vwall' && wallConnections.find(w => w.includes(obj)) == undefined) {
                    const sameX = grid.filter(w => w.x == obj.x && w.id == obj.id);
                    let connection = [];
                    for (let i = 0; i < HEIGHT; i++) {
                        const wall = sameX.find(w => w.y === i);
                        if (wall == undefined) {
                            if (connection.length > 0) wallConnections.push(connection);
                            connection = [];
                        }
                        else {
                            connection.push(wall);
                        }
                    }
                }
                else if (obj.id === 'tree') trees.push({
                    x: (obj.x + 1) * TILESIZE + 27,
                    y: (obj.y + 1) * TILESIZE + 35
                });
                else if (obj.id === 'ospawn') olofSpawns.push({
                    x: obj.x * TILESIZE,
                    y: obj.y * TILESIZE
                });
            }

            for (const connection of wallConnections) {
                walls.push({
                    x: connection[0].x * TILESIZE,
                    y: connection[0].y * TILESIZE,
                    dx: connection[0].id === 'hwall' ? connection.length * TILESIZE : 0,
                    dy: connection[0].id === 'vwall' ? connection.length * TILESIZE : 0
                });
            }

            return {
                id: 'exported_level',
                title: 'Exported Level',
                wallPositions: walls,
                treePositions: trees,
                olof: {
                    enabled: olofSpawns.length > 0,
                    spawns: olofSpawns,
                    speed: 5,
                    roaming: true,
                    huntRadius: 175,
                    roamRadius: 100
                },
                night: {
                    enabled: false,
                    radius: 200,
                    olofView: false
                },
                player: {
                    speed: 4,
                    spawn: {
                        x: grid.find(x => x.id == 'pspawn').x * TILESIZE,
                        y: grid.find(x => x.id == 'pspawn').y * TILESIZE
                    }
                },
                snowTimer: 1500,
                snowParticleAmount: 150,
                time: {
                    start: '2069-04-20 09:00',
                    end: '2069-04-20 15:00',
                    realTime: 180,
                },
                music: 'music/gtkiajnieoifawhniotftganwiofranfoia.mp3',
                pointCap: 150000000
            };
        }
    </script>
</body>

</html>